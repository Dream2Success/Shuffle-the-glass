<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Find the Bowl — Polished Responsive Shell Game</title>
<meta name="description" content="Attractive responsive shell game (find the bowl). Single-file HTML ready for GitHub Pages.">
<style>
  /* ===========================
     Theme variables (easy to tweak)
     =========================== */
  :root{
    --bg-1: #071026;
    --bg-2: #051029;
    --card: linear-gradient(180deg,#07182d,#04121b);
    --muted: #9fb0cc;
    --accent: #7ee3ff;
    --glass-max: 120px;
    --glass-min: 64px;
    --glass-w: clamp(var(--glass-min), 16vw, var(--glass-max));
    --glass-h: calc(var(--glass-w) * 1.38);
    --table-padding: 18px;
    --table-height: calc(var(--glass-h) + 110px);
    --gap-min: 8px;
    --gap-ideal: 3vw;
    --slot-gap: clamp(var(--gap-min), var(--gap-ideal), 14px);
    --radius: 14px;
    --card-shadow: 0 12px 36px rgba(2,8,20,0.6);
    --glass-shadow: 0 12px 28px rgba(3,9,22,0.6);
    --glass-border: rgba(255,255,255,0.06);
    --success: rgba(110,255,180,0.12);
    --fail: rgba(255,110,110,0.10);
    --font-sans: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  }

  /* ===========================
     Page layout
     =========================== */
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;font-family:var(--font-sans);-webkit-font-smoothing:antialiased;background:
    radial-gradient(900px 380px at 10% 8%, rgba(10,30,60,0.35), transparent 14%),
    linear-gradient(180deg,var(--bg-1),var(--bg-2)); color:#eaf2ff}
  .wrap{min-height:100%;display:flex;align-items:center;justify-content:center;padding:18px}
  .card{width:100%;max-width:1100px;background:var(--card);border-radius:16px;padding:18px 18px 22px;box-shadow:var(--card-shadow);border:1px solid rgba(255,255,255,0.02)}
  header{display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap}
  h1{margin:0;font-size:20px;letter-spacing:0.2px}
  .lead{margin:0;color:var(--muted);font-size:13px}

  /* ===========================
     Arena + table
     =========================== */
  .arena{margin-top:14px;border-radius:12px;padding:14px;background:linear-gradient(180deg, rgba(255,255,255,0.015), transparent);display:flex;flex-direction:column;align-items:center}
  .table-wrap{width:100%;max-width:var(--max-arena-width,980px);padding:10px;box-sizing:border-box}
  .table{
    width:100%;
    height:var(--table-height);
    border-radius:12px;
    position:relative;
    overflow:hidden;
    background:
      linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.04)),
      repeating-linear-gradient(90deg, rgba(255,255,255,0.01) 0 1px, transparent 2px 20px);
    box-shadow: 0 10px 36px rgba(0,0,0,0.45) inset;
    padding:var(--table-padding);
  }

  /* table surface (wood strip) */
  .surface{
    position:absolute;
    left:6%;
    right:6%;
    bottom:20px;
    height:20px;
    border-radius:999px;
    background: linear-gradient(180deg,#b07a3a,#6b3b07);
    box-shadow: 0 10px 24px rgba(0,0,0,0.6);
    z-index:2;
    pointer-events:none;
  }

  /* positions container (absolute slots placed inside) */
  .positions{position:relative;width:100%;height:100%}

  /* ===========================
     Slot & glass visuals
     =========================== */
  .slot{
    position:absolute;
    width:var(--glass-w);
    height:var(--glass-h);
    display:flex;
    align-items:flex-end;
    justify-content:center;
    cursor:pointer;
    user-select:none;
    touch-action:manipulation;
    transition: left 620ms cubic-bezier(.2,.9,.3,1), top 420ms ease, transform 220ms ease;
    z-index:10;
  }
  .slot .hit{ position:absolute; left:-8px; right:-8px; top:0; bottom:0; display:block }

  /* glass body: subtle frosted glass effect with SVG accent below */
  .glass{
    width:100%;
    height:84%;
    border-radius:14px 14px 36px 36px;
    background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
    border: 2px solid var(--glass-border);
    box-shadow: var(--glass-shadow);
    display:flex;align-items:flex-end;justify-content:center;padding-bottom:16px;overflow:visible;position:relative;
    transition: box-shadow .28s ease, outline .22s ease, transform .22s ease;
  }
  .glass::after{
    content:'';
    position:absolute;left:12%;top:10%;width:30%;height:44%;border-radius:70%;background:linear-gradient(180deg,rgba(255,255,255,0.18),rgba(255,255,255,0.02));filter:blur(6px);
    transform:rotate(-18deg);opacity:0.92;pointer-events:none;
  }

  /* decorative glass foot (small ellipse) */
  .foot{
    position:absolute;bottom:-8px;width:60%;height:16px;border-radius:999px;background:linear-gradient(180deg,rgba(0,0,0,0.2),rgba(255,255,255,0.03));filter: blur(1px);
    box-shadow: 0 6px 18px rgba(0,0,0,0.28);opacity:0.8;
  }

  .bowl{
    width: calc(var(--glass-w) * 0.36);
    height: calc(var(--glass-w) * 0.36);
    border-radius:50%;
    position:absolute;
    bottom:26px;
    box-shadow: 0 10px 26px rgba(0,0,0,0.45), inset 0 -6px 12px rgba(0,0,0,0.12);
    transition: opacity 220ms ease, transform 300ms cubic-bezier(.2,.9,.3,1);
    opacity:0;
    z-index:12;
    pointer-events:none;
  }
  .bowl.show{ opacity:1; transform: translateY(-8px) scale(1.03); }

  /* labels beneath */
  .label{margin-top:8px;text-align:center;font-size:13px;color:var(--muted);}

  /* button group */
  .controls{display:flex;gap:12px;align-items:center;margin-top:16px;flex-wrap:wrap}
  .btn{
    background: linear-gradient(180deg,#1f6feb,#2c8cff);
    color:white;border:none;padding:12px 16px;border-radius:12px;font-weight:700;cursor:pointer;box-shadow:0 8px 20px rgba(44,140,255,0.12);
    min-width:110px;
  }
  .btn.ghost{ background:transparent;border:1px solid rgba(255,255,255,0.06); color:#d7e8ff; }

  .status{margin-top:12px;font-size:15px;color:var(--muted);min-height:24px;text-align:center}

  /* success / fail */
  .glass.correct{ outline:6px solid var(--success); box-shadow: 0 30px 80px rgba(110,255,180,0.06);}
  .glass.wrong{ outline:5px solid var(--fail); }

  /* shake animation */
  @keyframes shake {
    0% { transform: translateX(0) }
    20% { transform: translateX(-9px) }
    40% { transform: translateX(6px) }
    60% { transform: translateX(-6px) }
    80% { transform: translateX(3px) }
    100% { transform: translateX(0) }
  }
  .shake{ animation: shake 520ms cubic-bezier(.25,.8,.25,1); }

  /* confetti */
  .confetti{ position:absolute;left:0;right:0;top:0;bottom:0;pointer-events:none;overflow:hidden;z-index:60 }
  .confetti i{position:absolute;display:block;width:9px;height:14px;border-radius:2px;opacity:0.95;transform-origin:center}

  /* responsive */
  @media (max-width:720px){
    .card{padding:14px}
    h1{font-size:18px}
    .controls{gap:8px}
    .btn{min-width:unset;width:100%}
  }

  /* focus styles for accessibility */
  .slot:focus-visible{ outline:3px solid rgba(80,160,255,0.14); outline-offset:6px; border-radius:12px }
  button:focus-visible{ box-shadow:0 10px 30px rgba(44,140,255,0.18) }
</style>
</head>
<body>
<div class="wrap">
  <main class="card" role="application" aria-label="Find the bowl under glass game">
    <header>
      <div>
        <h1>Find the Bowl</h1>
        <p class="lead">Watch the bowl, follow the glasses on the table, and pick the correct one. Responsive & mobile-ready.</p>
      </div>
      <div style="text-align:right">
        <div style="font-size:12px;color:var(--muted)">Status: <strong id="mode">Ready</strong></div>
      </div>
    </header>

    <section class="arena" aria-live="polite">
      <div class="table-wrap">
        <div class="table" id="table" aria-label="Game table">
          <div class="surface" aria-hidden="true"></div>
          <div class="positions" id="positions" role="list" aria-label="Glass positions"></div>
          <div class="confetti" id="confetti" aria-hidden="true"></div>
        </div>
      </div>

      <div class="controls" role="group" aria-label="Game controls">
        <button id="startBtn" class="btn" aria-label="Start game">Start</button>
        <button id="revealBtn" class="btn ghost" aria-label="Reveal answer">Reveal</button>
        <button id="resetBtn" class="btn ghost" aria-label="Reset game">Reset</button>
      </div>

      <div class="status" id="statusText">Press <strong>Start</strong> to show the bowl briefly, then the glasses will shuffle.</div>
    </section>

    <footer style="margin-top:12px;display:flex;justify-content:space-between;align-items:center;color:var(--muted);font-size:13px">
      <div>Single-file • Host on GitHub Pages</div>
      <div>Glasses stay on the table • Mobile-friendly</div>
    </footer>
  </main>
</div>

<script>
/* Polished shell game logic
   - Table bounded: compute 3 safe left positions inside the table and animate slots using left/top.
   - Start: resets, then shows bowl, then shuffles by swapping order[] and moving slots.
   - Responsive: recomputes positions on resize.
   - Single-file, no external libs.
*/

(() => {
  const positionsEl = document.getElementById('positions');
  const tableEl = document.getElementById('table');
  const startBtn = document.getElementById('startBtn');
  const revealBtn = document.getElementById('revealBtn');
  const resetBtn = document.getElementById('resetBtn');
  const statusText = document.getElementById('statusText');
  const modeText = document.getElementById('mode');
  const confettiRoot = document.getElementById('confetti');

  let slots = [];              // slots keyed by original index order [0..2]
  let order = [0,1,2];         // visualPos -> originalIndex mapping
  let posLefts = [0,0,0];      // computed left positions for visual 0..2
  let hiddenIndex = 0;         // original index where bowl is hidden
  let animating = false;
  let swapInterval = null;
  let shuffleTimeout = null;

  const REVEAL_MS = 1000;
  const SHUFFLE_MS = 5200;
  const SWAP_EVERY = 620;
  const MIN_GAP = 8;

  // Helpers
  const randRGB = () => {
    const r = 80 + Math.floor(Math.random()*176);
    const g = 60 + Math.floor(Math.random()*196);
    const b = 60 + Math.floor(Math.random()*196);
    return `rgb(${r},${g},${b})`;
  };
  const makeBowlGradient = () => {
    const a = randRGB(); const b = randRGB();
    return `radial-gradient(circle at 30% 30%, ${a}, ${b})`;
  };

  // Build three slot elements
  function buildSlots(){
    positionsEl.innerHTML = '';
    slots = [];
    for(let i=0;i<3;i++){
      const slot = document.createElement('div');
      slot.className = 'slot';
      slot.dataset.index = i;
      slot.tabIndex = 0;
      slot.setAttribute('role','button');
      slot.setAttribute('aria-label', `Glass ${i+1}`);
      slot.innerHTML = `
        <div class="hit" aria-hidden="true"></div>
        <div class="glass" data-glass="${i}">
          <div class="bowl" data-ball-for="${i}" aria-hidden="true"></div>
          <div class="foot" aria-hidden="true"></div>
        </div>
        <div class="label">Glass ${i+1}</div>
      `;
      // event handlers
      slot.addEventListener('click', onGuess, {passive:true});
      slot.addEventListener('touchstart', (e)=>{ e.preventDefault(); onGuess({currentTarget: slot}); }, {passive:false});
      slot.addEventListener('keydown', (e)=>{ if(e.key === 'Enter' || e.key === ' '){ e.preventDefault(); onGuess({currentTarget: slot}); } });
      positionsEl.appendChild(slot);
      slots.push(slot);
    }
    // initialize visual order -> natural left-to-right
    order = [0,1,2];
    computeLeftPositions();
    applyLefts(true);
  }

  // compute three left positions that fit inside table and keep slots inside
  function computeLeftPositions(){
    const positionsRect = positionsEl.getBoundingClientRect();
    let containerWidth = positionsRect.width || (tableEl.getBoundingClientRect().width - 2*parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--table-padding') || 18));
    // measure actual slot width by reading CSS variable or DOM
    let cssW = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--glass-w')) || 100;
    // If slots already in DOM, get computed width for better accuracy
    if(slots[0]){
      const measured = slots[0].getBoundingClientRect().width;
      if(measured && measured > 10) cssW = measured;
    }
    // Ensure slots fit: compute gap
    let totalGap = containerWidth - (3 * cssW);
    const minGap = MIN_GAP;
    if(totalGap < 2 * minGap){
      // shrink cssW proportionally
      const targetW = Math.max(48, (containerWidth - 2*minGap)/3);
      cssW = targetW;
      totalGap = containerWidth - (3 * cssW);
    }
    const gap = Math.max(minGap, totalGap / 2);
    // left0 centered in container with padding
    const left0 = Math.round(Math.max(8, (containerWidth - (3*cssW + 2*gap)) / 2));
    posLefts[0] = left0;
    posLefts[1] = Math.round(left0 + cssW + gap);
    posLefts[2] = Math.round(left0 + 2*(cssW + gap));
    // enforce explicit width/height on slots to avoid layout jumping
    slots.forEach(s => {
      s.style.width = cssW + 'px';
      s.style.height = (cssW * 1.38) + 'px';
    });
  }

  // apply left positions according to current order; instant toggle if instant=true
  function applyLefts(instant = false){
    slots.forEach((slot, origIndex) => {
      const visualPos = order.indexOf(origIndex);
      const left = posLefts[visualPos] || 0;
      if(instant) slot.style.transition = 'none';
      slot.style.left = left + 'px';
      // top: place slot above the surface nicely
      const containerH = positionsEl.getBoundingClientRect().height || (parseFloat(slot.style.height) + 80);
      const slotH = slot.getBoundingClientRect().height || parseFloat(slot.style.height) || 120;
      const top = Math.max(14, containerH - slotH - 44); // give some room
      slot.style.top = top + 'px';
      // reset states
      const glass = slot.querySelector('.glass');
      glass.classList.remove('correct','wrong');
      const bowl = slot.querySelector('.bowl');
      if(bowl){ bowl.classList.remove('show'); bowl.style.opacity = 0; }
    });
    if(instant){
      // force reflow and restore transition
      void positionsEl.offsetHeight;
      slots.forEach(s => s.style.transition = 'left 620ms cubic-bezier(.2,.9,.3,1), top 420ms ease, transform 220ms ease');
    }
  }

  // animate swapping of two visual positions (iPos,jPos)
  function swapPositions(iPos, jPos){
    // swap values in order array (visual index -> original index mapping)
    const temp = order[iPos];
    order[iPos] = order[jPos];
    order[jPos] = temp;
    // apply animation to move slots to new lefts
    applyLefts(false);
  }

  // reveal bowl briefly under the original hiddenIndex
  function showBowlTemporarily(cb){
    const bowl = slots[hiddenIndex].querySelector('.bowl');
    bowl.style.background = makeBowlGradient();
    bowl.classList.add('show');
    bowl.style.opacity = 1;
    setTimeout(()=> {
      bowl.classList.remove('show');
      bowl.style.opacity = 0;
      cb && cb();
    }, REVEAL_MS);
  }

  // set round colors (glass BG and bowl)
  function colorizeRound(){
    for(let i=0;i<3;i++){
      const g = slots[i].querySelector('.glass');
      const rgb = randRGB();
      const rgba = rgb.replace('rgb','rgba').replace(')',',0.12)');
      g.style.background = `linear-gradient(180deg, ${rgba}, rgba(255,255,255,0.02))`;
      g.style.borderColor = `rgba(255,255,255,0.06)`;
      const bowl = slots[i].querySelector('.bowl');
      bowl.style.background = makeBowlGradient();
    }
  }

  // Start: reset and begin shuffle
  function startGame(){
    if(animating) return;
    animating = true;
    modeText.textContent = 'Preparing';
    statusText.textContent = 'Resetting and showing bowl...';
    // reset: natural order and recompute lefts
    order = [0,1,2];
    computeLeftPositions();
    applyLefts(true);

    hiddenIndex = Math.floor(Math.random()*3);
    colorizeRound();
    // show bowl then shuffle
    showBowlTemporarily(()=> {
      modeText.textContent = 'Shuffling';
      statusText.textContent = 'Shuffling — follow the glasses!';
      const endAt = Date.now() + SHUFFLE_MS;
      swapInterval = setInterval(()=> {
        const i = Math.floor(Math.random()*3);
        let j = Math.floor(Math.random()*3); while(j===i) j = Math.floor(Math.random()*3);
        swapPositions(i,j);
        if(Date.now() >= endAt){
          clearInterval(swapInterval); swapInterval = null;
          animating = false;
          modeText.textContent = 'Choose';
          statusText.textContent = 'Tap the glass you think hides the bowl.';
        }
      }, SWAP_EVERY);
      // safety stop
      shuffleTimeout = setTimeout(()=> {
        if(swapInterval){ clearInterval(swapInterval); swapInterval = null; animating = false; modeText.textContent='Choose'; statusText.textContent='Tap the glass you think hides the bowl.'; }
      }, SHUFFLE_MS + 300);
    });
  }

  // User guess handler
  function onGuess(e){
    const slotEl = e.currentTarget;
    if(!slotEl) return;
    if(animating) return;
    animating = true;
    const clickedOriginal = Number(slotEl.dataset.index);
    const correct = clickedOriginal === hiddenIndex;

    // reveal real bowl after tiny delay
    setTimeout(()=> {
      const trueSlot = slots.find(s => Number(s.dataset.index) === hiddenIndex);
      if(trueSlot){
        const ball = trueSlot.querySelector('.bowl');
        ball.style.background = makeBowlGradient();
        ball.classList.add('show');
        ball.style.opacity = 1;
      }
    }, 160);

    if(correct){
      modeText.textContent = 'Correct!';
      statusText.innerHTML = `<strong>Correct!</strong> You found the bowl under Glass ${hiddenIndex+1}. Nice!`;
      const trueSlot = slots.find(s => Number(s.dataset.index) === hiddenIndex);
      if(trueSlot){ const g = trueSlot.querySelector('.glass'); g.classList.add('correct'); trueSlot.animate([{ transform:'translateY(0)' },{ transform:'translateY(-12px)' },{ transform:'translateY(0)' }], { duration:520, easing:'cubic-bezier(.2,.9,.3,1)' }); }
      setTimeout(()=> { animating = false; }, 900);
    } else {
      modeText.textContent = 'Wrong';
      statusText.innerHTML = `<strong>Wrong.</strong> You tapped Glass ${clickedOriginal+1}. The bowl was under Glass ${hiddenIndex+1}.`;
      slotEl.querySelector('.glass')?.classList.add('wrong');
      slotEl.classList.add('shake');
      setTimeout(()=> {
        slotEl.classList.remove('shake');
        const trueSlot = slots.find(s => Number(s.dataset.index) === hiddenIndex);
        if(trueSlot){ trueSlot.querySelector('.glass')?.classList.add('correct'); spawnConfettiAt(trueSlot); }
      }, 340);
      setTimeout(()=> { animating = false; }, 1400);
    }
  }

  // Reveal handler
  function reveal(){
    if(animating) return;
    const trueSlot = slots.find(s => Number(s.dataset.index) === hiddenIndex);
    if(trueSlot){ trueSlot.querySelector('.bowl')?.classList.add('show'); trueSlot.querySelector('.glass')?.classList.add('correct'); }
    modeText.textContent = 'Revealed';
    statusText.textContent = 'Answer revealed. Reset or Start to play again.';
  }

  // Reset game
  function resetGame(){
    if(swapInterval){ clearInterval(swapInterval); swapInterval = null; }
    if(shuffleTimeout){ clearTimeout(shuffleTimeout); shuffleTimeout = null; }
    animating = false;
    modeText.textContent = 'Ready';
    statusText.textContent = 'Reset. Press Start to play.';
    clearConfetti();
    order = [0,1,2];
    computeLeftPositions();
    applyLefts(true);
  }

  // Confetti burst at target slot element (nice on success)
  function spawnConfettiAt(slotEl){
    // compute center of slot's glass to spawn
    const g = slotEl.querySelector('.glass');
    const rootRect = confettiRoot.getBoundingClientRect();
    const gRect = g.getBoundingClientRect();
    const centerX = (gRect.left + gRect.right)/2 - rootRect.left;
    const startY = Math.max(6, gRect.top - rootRect.top + 8);
    const pieces = 20;
    const colors = ['#ff4d6d','#ffd166','#06d6a0','#4cc9f0','#ff7eb6','#c77dff'];
    for(let i=0;i<pieces;i++){
      const e = document.createElement('i');
      const w = 6 + Math.random()*9;
      const h = 10 + Math.random()*18;
      e.style.width = w + 'px';
      e.style.height = h + 'px';
      e.style.left = (centerX + (Math.random()*100 - 50)) + 'px';
      e.style.top = (startY + (Math.random()*30 - 8)) + 'px';
      e.style.background = colors[Math.floor(Math.random()*colors.length)];
      e.style.transform = `rotate(${Math.random()*360}deg)`;
      confettiRoot.appendChild(e);
      const destX = (Math.random()*400 - 200);
      const destY = rootRect.height + 80 + Math.random()*160;
      const rot = Math.random()*720 - 360;
      e.animate([{ transform: `translateY(0) rotate(${Math.random()*360}deg)`, opacity:1 }, { transform: `translate(${destX}px, ${destY}px) rotate(${rot}deg)`, opacity:0.08 }], { duration: 1100 + Math.random()*900, easing: 'cubic-bezier(.2,.8,.2,1)' });
      setTimeout(()=> { if(e && e.parentNode) e.parentNode.removeChild(e) }, 2200);
    }
  }

  function clearConfetti(){ confettiRoot.innerHTML = ''; }

  // recompute positions on resize (throttled)
  let resizeTimer = 0;
  window.addEventListener('resize', ()=> {
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(()=> {
      computeLeftPositions();
      applyLefts(true);
    }, 140);
  });

  // Quick start: wire up handlers
  startBtn.addEventListener('click', ()=> { resetGame(); requestAnimationFrame(()=> startGame()); }, {passive:true});
  startBtn.addEventListener('touchstart', (e)=> { e.preventDefault(); startBtn.click(); }, {passive:false});
  revealBtn.addEventListener('click', reveal, {passive:true});
  revealBtn.addEventListener('touchstart', (e)=> { e.preventDefault(); revealBtn.click(); }, {passive:false});
  resetBtn.addEventListener('click', resetGame, {passive:true});
  resetBtn.addEventListener('touchstart', (e)=> { e.preventDefault(); resetBtn.click(); }, {passive:false});

  // initial mount
  window.addEventListener('load', ()=> {
    buildSlots();
    // tiny intro bounce
    setTimeout(()=> {
      slots.forEach((s,i)=> { s.style.transform = 'translateY(8px)'; setTimeout(()=> s.style.transform = '', 140 + i*80); });
    }, 120);
  });

  // expose for debugging (optional)
  window._shellGame = { startGame, resetGame };
})();
</script>
</body>
</html>

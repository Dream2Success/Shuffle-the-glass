<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Find the Bowl — Table-bounded Shell Game</title>
<style>
  :root{
    --bg:#071028;
    --muted:#9fb0cc;
    /* responsive glass width: min 64px, ideal 16vw, max 110px */
    --glass-w: clamp(64px, 16vw, 110px);
    --glass-h: calc(var(--glass-w) * 1.35);
    --table-h:20px;
    --slot-gap: clamp(8px, 3vw, 14px);
    --table-padding: 16px;
    --max-arena-width:760px;
  }

  html,body{
    height:100%;
    margin:0;
    font-family:Inter,system-ui,-apple-system,"Segoe UI",Roboto,Arial;
    color:#eaf2ff;
    background: radial-gradient(800px 300px at 10% 10%, #07203a 0%, var(--bg) 30%), var(--bg);
    -webkit-font-smoothing:antialiased;
    -moz-osx-font-smoothing:grayscale;
    -webkit-tap-highlight-color: transparent;
    touch-action: manipulation;
  }

  .wrap{min-height:100%;display:flex;align-items:center;justify-content:center;padding:16px;box-sizing:border-box}
  .card{width:100%;max-width:980px;background:linear-gradient(180deg,#051129,#08121b);border-radius:14px;padding:16px;box-shadow:0 10px 30px rgba(3,8,16,0.7)}
  header{display:flex;flex-wrap:wrap;justify-content:space-between;align-items:center;gap:10px}
  h1{font-size:20px;margin:0;display:flex;gap:12px;align-items:center}
  p.lead{margin:0;color:var(--muted);font-size:13px;line-height:1.25}

  /* Game area */
  .arena{margin-top:14px;border-radius:12px;padding:14px;background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent);display:flex;flex-direction:column;align-items:center}
  /* table: fixed horizontal area where slots move; overflow hidden to keep them inside */
  .table{width:100%;max-width:var(--max-arena-width);height:calc(var(--glass-h) + 110px);position:relative;display:block;box-sizing:border-box;overflow:hidden;padding:calc(var(--table-padding)); background:
    linear-gradient(180deg, rgba(255,255,255,0.01), transparent); border-radius:10px;}
  .surface{position:absolute;left:6%;right:6%;bottom:12px;height:var(--table-h);background:linear-gradient(180deg,#6b3b07,#3a1f03);border-radius:999px;box-shadow:0 8px 18px rgba(0,0,0,0.5);pointer-events:none;z-index:2}

  .positions{ position:relative; width:100%; height:100%; } /* container for absolute slots */

  .slot{
    position:absolute;  /* we'll set left/top in JS so slots remain inside table */
    width:var(--glass-w);
    height:var(--glass-h);
    display:flex;
    align-items:flex-end;
    justify-content:center;
    cursor:pointer;
    user-select:none;
    touch-action:manipulation;
    transition: left 580ms cubic-bezier(.2,.9,.3,1), transform 360ms ease;
    z-index:10;
  }
  .slot .hit{ position:absolute; left:-8px; right:-8px; top:0; bottom:0; display:block; } /* larger touch area */

  .glass{
    width:100%;
    height:84%;
    border-radius:12px 12px 34px 34px;
    display:flex;
    align-items:flex-end;
    justify-content:center;
    padding-bottom:14px;
    box-shadow:0 10px 18px rgba(0,0,0,0.38), inset 0 -8px 22px rgba(0,0,0,0.12);
    border:2px solid rgba(255,255,255,0.06);
    transition: box-shadow .28s ease, outline .28s ease, transform .22s ease;
    overflow:visible;
    background: linear-gradient(180deg, rgba(255,255,255,0.03), rgba(255,255,255,0.01));
  }
  .glass::after{ content:''; position:absolute; left:12%; top:12%; width:30%; height:46%; border-radius:70%; background:linear-gradient(180deg,rgba(255,255,255,0.18),rgba(255,255,255,0.02)); filter:blur(6px); transform:rotate(-18deg); opacity:0.9; pointer-events:none; }

  .bowl{
    width: calc(var(--glass-w) * 0.36);
    height: calc(var(--glass-w) * 0.36);
    border-radius:50%;
    position:absolute;
    bottom:18px;  /* sits on the table */
    box-shadow:0 8px 20px rgba(0,0,0,0.45), inset 0 -6px 10px rgba(0,0,0,0.10);
    transition: transform 300ms ease, opacity 200ms ease;
    opacity:0;
    z-index:12;
    pointer-events:none;
  }
  .bowl.show{ opacity:1; transform: translateY(-6px) scale(1.02); }

  .label{ margin-top:10px; text-align:center; font-size:13px; color:var(--muted); }
  .controls{ display:flex; gap:10px; align-items:center; justify-content:center; margin-top:12px; flex-wrap:wrap; }
  .btn{ background:linear-gradient(180deg,#1f6feb,#2c8cff); color:white; border:none; padding:12px 16px; border-radius:12px; font-weight:700; cursor:pointer; box-shadow:0 8px 24px rgba(44,140,255,0.12); min-width:110px }
  .btn.alt{ background:transparent; color:#d7e8ff; border:1px solid rgba(255,255,255,0.06) }
  .status{ margin-top:10px; text-align:center; font-size:15px; color:var(--muted); min-height:24px; line-height:1.2 }
  footer{ display:flex; flex-wrap:wrap; justify-content:space-between; align-items:center; gap:10px; margin-top:12px; color:var(--muted); font-size:13px }

  .glass.correct{ outline:5px solid rgba(110,255,180,0.13); box-shadow:0 24px 60px rgba(110,255,180,0.06) }
  .glass.wrong{ outline:4px solid rgba(255,110,110,0.12) }

  @keyframes shake { 0%{ transform:translateX(0) } 20%{ transform:translateX(-8px) } 40%{ transform:translateX(6px) } 60%{ transform:translateX(-6px) } 80%{ transform:translateX(3px) } 100%{ transform:translateX(0) } }
  .shake{ animation:shake 520ms cubic-bezier(.25,.8,.25,1); }

  .confetti{ pointer-events:none; position:absolute; left:0; right:0; top:0; bottom:0; overflow:hidden; z-index:60; }
  .confetti i{ position:absolute; display:block; width:9px; height:14px; opacity:0.95; transform-origin:center; border-radius:2px; }

  /* responsive */
  @media (max-width:640px){
    :root{ --slot-gap: clamp(6px, 5vw, 10px); }
    h1{ font-size:18px; }
    .btn{ padding:12px 14px; min-width:unset; width:100%; }
    .controls{ flex-direction:column; align-items:stretch; }
    .status{ font-size:14px; }
  }
  .slot:focus-visible{ outline:3px solid rgba(80,160,255,0.14); outline-offset:6px; border-radius:10px; }
  button:focus-visible{ box-shadow:0 8px 26px rgba(44,140,255,0.18); }
</style>
</head>
<body>
<div class="wrap">
  <div class="card" role="application" aria-label="Find the bowl under a glass game">
    <header>
      <div>
        <h1>Find the Bowl — Bounded to Table</h1>
        <p class="lead">Glasses move only on the table area and will not go outside. Tap <strong>Start</strong> (resets first) to play.</p>
      </div>
      <div style="text-align:right">
        <div style="font-size:12px;color:var(--muted)">Status: <strong id="mode">Ready</strong></div>
      </div>
    </header>

    <div class="arena" id="arena">
      <div class="table" id="table" aria-live="polite">
        <div class="surface" aria-hidden="true"></div>

        <div class="positions" id="positions" role="list" aria-label="Glass positions">
          <!-- JS will create absolute-positioned .slot children here -->
        </div>

        <div class="confetti" id="confetti" aria-hidden="true"></div>
      </div>

      <div class="controls" aria-hidden="false">
        <button class="btn" id="startBtn" aria-label="Start game">Start</button>
        <button class="btn alt" id="revealBtn" aria-label="Reveal answer">Reveal</button>
        <button class="btn alt" id="resetBtn" aria-label="Reset game">Reset</button>
      </div>

      <div class="status" id="statusText">Press <strong>Start</strong> to begin. The bowl will appear briefly then hide.</div>

      <footer>
        <div style="opacity:0.9">Single-file • Drop as <code>index.html</code> for GitHub Pages</div>
        <div style="font-size:13px;color:var(--muted)">Glasses remain on the table and won't overflow</div>
      </footer>
    </div>
  </div>
</div>

<script>
/* Table-bounded shell game
 - Slots are absolutely positioned within the table.
 - Left positions are computed so slots stay fully inside the table.
 - Swaps animate by changing left values (no overflow).
 - Start resets first and then starts.
*/

(() => {
  const table = document.getElementById('table');
  const positionsEl = document.getElementById('positions');
  const startBtn = document.getElementById('startBtn');
  const revealBtn = document.getElementById('revealBtn');
  const resetBtn = document.getElementById('resetBtn');
  const statusText = document.getElementById('statusText');
  const modeText = document.getElementById('mode');
  const confettiRoot = document.getElementById('confetti');

  let slots = [];              // array of slot DOMs (original index order)
  let posLefts = [0,0,0];      // computed left pixel positions for the three visual positions
  let order = [0,1,2];         // mapping: visualPos -> originalIndex
  let hiddenIndex = 0;         // original index where bowl is hidden
  let animating = false;
  let swapInterval = null;
  let shuffleTimeout = null;

  const revealLength = 1000;      // ms to show bowl before shuffle
  const shuffleDuration = 5200;   // total ms for shuffling
  const swapEvery = 600;          // ms between swaps
  const tablePadding = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--table-padding')) || 16;

  function randRGB(){
    const r = 80 + Math.floor(Math.random()*176);
    const g = 60 + Math.floor(Math.random()*196);
    const b = 60 + Math.floor(Math.random()*196);
    return `rgb(${r},${g},${b})`;
  }
  function makeBowlGradient(){ const a = randRGB(); const b = randRGB(); return `radial-gradient(circle at 30% 30%, ${a}, ${b})`; }

  // create three slots (original indices 0..2)
  function buildSlots(){
    positionsEl.innerHTML = '';
    slots = [];
    for(let i=0;i<3;i++){
      const s = document.createElement('div');
      s.className = 'slot';
      s.dataset.index = i; // original index
      s.setAttribute('role','button');
      s.setAttribute('tabindex','0');
      s.setAttribute('aria-label', `Glass ${i+1}`);
      s.innerHTML = `
        <div class="hit" aria-hidden="true"></div>
        <div class="glass" data-glass="${i}">
          <div class="bowl" data-ball-for="${i}" aria-hidden="true"></div>
        </div>
        <div class="label">Glass ${i+1}</div>
      `;
      // add event listeners
      s.addEventListener('click', onGuess, {passive:true});
      s.addEventListener('touchstart', (e)=> { e.preventDefault(); onGuess({currentTarget: s}); }, {passive:false});
      s.addEventListener('keydown', (e)=> { if(e.key === 'Enter' || e.key === ' '){ e.preventDefault(); onGuess({currentTarget: s}); }});
      positionsEl.appendChild(s);
      slots.push(s);
    }
    // initial mapping visualPos -> original index
    order = [0,1,2];
    // compute lefts and position them
    computeLeftPositions();
    applyLeftsInstant();
  }

  // compute left pixel positions (three slots) so they remain inside table
  function computeLeftPositions(){
    const containerRect = positionsEl.getBoundingClientRect();
    let containerWidth = containerRect.width;
    if(containerWidth === 0){
      // fallback: measure table inner width minus padding
      const tableRect = table.getBoundingClientRect();
      containerWidth = Math.max(300, tableRect.width - tablePadding*2);
    }
    // get current slot width (computed from CSS)
    const slotW = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--glass-w')) || slots[0]?.getBoundingClientRect().width || 100;
    // ensure slotW is numeric pixels if clamp() returned percent; try reading actual DOM if available
    if(slots[0]){
      const rect = slots[0].getBoundingClientRect();
      if(rect.width) { /* prefer actual width */ }
    }
    // compute actual slot pixel width by reading one slot's bounding box after it is in DOM
    let actualSlotW = slotW;
    if(slots[0]){
      const r = slots[0].getBoundingClientRect();
      if(r.width && r.width > 10) actualSlotW = r.width;
    }
    // spacing available between slots (two gaps)
    // aim for a minimum gap and distribute remaining space
    const minGap = Math.max(8, (containerWidth * 0.02)); // at least 8px
    // available space for gaps = containerWidth - 3*slotW
    let totalGapSpace = containerWidth - (3 * actualSlotW);
    if(totalGapSpace < 2 * minGap){
      // if not enough, shrink slot width proportionally so they fit (user said small is ok)
      const targetSlotW = (containerWidth - 2 * minGap) / 3;
      actualSlotW = Math.max(40, targetSlotW);
      totalGapSpace = containerWidth - (3 * actualSlotW);
    }
    const gap = Math.max(minGap, totalGapSpace / 2);
    // left positions relative to positionsEl left
    const left0 = Math.max(8, (containerWidth - (3 * actualSlotW + 2*gap)) / 2);
    posLefts[0] = left0;
    posLefts[1] = left0 + actualSlotW + gap;
    posLefts[2] = left0 + 2*(actualSlotW + gap);
    // set slot widths explicitly to avoid surprises
    slots.forEach(s => { s.style.width = actualSlotW + 'px'; s.style.height = (actualSlotW * 1.35) + 'px'; });
  }

  // place according to posLefts and current order instantly (no animation)
  function applyLeftsInstant(){
    slots.forEach((slot, origIdx) => {
      const visualPos = order.indexOf(origIdx);
      const left = posLefts[visualPos] || 0;
      slot.style.transition = 'none';
      slot.style.left = left + 'px';
      // place top so bottom aligns above table surface: compute from container height
      const containerH = positionsEl.getBoundingClientRect().height;
      const slotH = slot.getBoundingClientRect().height || (parseFloat(getComputedStyle(slot).height) || 120);
      const top = Math.max(16, containerH - slotH - 28); // keep some top spacing
      slot.style.top = top + 'px';
      // reset visual states
      const g = slot.querySelector('.glass');
      g.classList.remove('correct','wrong');
      const b = slot.querySelector('.bowl');
      if(b){ b.classList.remove('show'); b.style.opacity = 0; }
      slot.style.zIndex = 10;
    });
    // force reflow then restore transitions
    void positionsEl.offsetHeight;
    slots.forEach(s => s.style.transition = 'left 580ms cubic-bezier(.2,.9,.3,1), transform 300ms ease');
  }

  // animate lefts according to order
  function animateToLefts(){
    slots.forEach((slot, origIdx) => {
      const visualPos = order.indexOf(origIdx);
      const left = posLefts[visualPos] || 0;
      slot.style.left = left + 'px';
      slot.style.zIndex = 20 + visualPos;
    });
  }

  // swap two visual positions (iPos,jPos) by swapping values in order[]
  function swapPositions(iPos, jPos){
    // swap the values stored at positions iPos and jPos
    const idxA = order[iPos];
    const idxB = order[jPos];
    for(let k=0;k<order.length;k++){
      if(order[k] === idxA) order[k] = idxB;
      else if(order[k] === idxB) order[k] = idxA;
    }
    // animate slots to new lefts
    animateToLefts();
  }

  // show bowl under original index temporarily
  function showBowlTemporarily(cb){
    const bowl = slots[hiddenIndex].querySelector('.bowl');
    bowl.style.background = makeBowlGradient();
    bowl.classList.add('show');
    bowl.style.opacity = 1;
    setTimeout(()=> {
      bowl.classList.remove('show');
      bowl.style.opacity = 0;
      cb && cb();
    }, revealLength);
  }

  // random RGB color for glass backgrounds and bowl
  function colorizeRound(){
    for(let i=0;i<3;i++){
      const g = slots[i].querySelector('.glass');
      const rgb = randRGB();
      const rgba = rgb.replace('rgb','rgba').replace(')',',0.12)');
      g.style.background = `linear-gradient(180deg, ${rgba}, rgba(255,255,255,0.02))`;
      g.style.borderColor = `rgba(255,255,255,0.06)`;
      const bowl = slots[i].querySelector('.bowl');
      bowl.style.background = makeBowlGradient();
    }
  }

  // start shuffle: reset first, then show bowl then swaps
  function startShuffle(){
    if(animating) return;
    animating = true;
    modeText.textContent = 'Preparing';
    statusText.textContent = 'Resetting & showing bowl briefly...';

    // reset order to natural before starting
    order = [0,1,2];
    computeLeftPositions();
    applyLeftsInstant();

    hiddenIndex = Math.floor(Math.random() * 3);
    colorizeRound();

    // show bowl then shuffle
    showBowlTemporarily(() => {
      modeText.textContent = 'Shuffling';
      statusText.textContent = 'Shuffling... watch carefully!';
      const endAt = Date.now() + shuffleDuration;
      swapInterval = setInterval(() => {
        const i = Math.floor(Math.random()*3);
        let j = Math.floor(Math.random()*3);
        while(j===i) j = Math.floor(Math.random()*3);
        swapPositions(i,j);
        if(Date.now() >= endAt){
          clearInterval(swapInterval);
          swapInterval = null;
          animating = false;
          modeText.textContent = 'Choose';
          statusText.textContent = 'Tap the glass you think hides the bowl.';
        }
      }, swapEvery);

      shuffleTimeout = setTimeout(()=> {
        if(swapInterval){ clearInterval(swapInterval); swapInterval = null; animating = false; modeText.textContent = 'Choose'; statusText.textContent = 'Tap the glass you think hides the bowl.'; }
      }, shuffleDuration + 300);
    });
  }

  // user guess
  function onGuess(e){
    const slot = e.currentTarget;
    if(!slot) return;
    if(animating) return;
    animating = true;
    const clickedOriginal = Number(slot.dataset.index);
    const correct = (clickedOriginal === hiddenIndex);

    // reveal true bowl after short delay
    setTimeout(()=> {
      const trueSlot = slots.find(s => Number(s.dataset.index) === hiddenIndex);
      if(trueSlot){
        const trueBowl = trueSlot.querySelector('.bowl');
        trueBowl.style.background = makeBowlGradient();
        trueBowl.classList.add('show');
        trueBowl.style.opacity = 1;
      }
    }, 160);

    if(correct){
      modeText.textContent = 'Correct!';
      statusText.innerHTML = `<strong>Correct!</strong> You found the bowl under Glass ${hiddenIndex+1}. Nice!`;
      const trueSlot = slots.find(s => Number(s.dataset.index) === hiddenIndex);
      if(trueSlot){ trueSlot.querySelector('.glass')?.classList.add('correct'); trueSlot.animate([{ transform: 'translateY(0)' }, { transform: 'translateY(-12px)' }, { transform: 'translateY(0)' }], { duration: 560, easing: 'cubic-bezier(.2,.9,.3,1)' }); }
      setTimeout(()=> { animating = false; }, 900);
    } else {
      modeText.textContent = 'Wrong';
      statusText.innerHTML = `<strong>Wrong.</strong> You tapped Glass ${clickedOriginal+1}. The bowl was under Glass ${hiddenIndex+1}.`;
      slot.querySelector('.glass')?.classList.add('wrong');
      slot.classList.add('shake');
      setTimeout(()=> {
        slot.classList.remove('shake');
        const trueSlot = slots.find(s => Number(s.dataset.index) === hiddenIndex);
        if(trueSlot){
          trueSlot.querySelector('.glass')?.classList.add('correct');
          spawnConfettiAt(trueSlot.querySelector('.glass'));
        }
      }, 360);
      setTimeout(()=> { animating = false; }, 1400);
    }
  }

  // reveal and reset handlers
  startBtn.addEventListener('click', ()=> {
    // reset first then start (resetGame will also clear running timers)
    resetGame();
    // ensure layout computed then start
    requestAnimationFrame(()=> { startShuffle(); });
  }, {passive:true});
  startBtn.addEventListener('touchstart', (e)=> { e.preventDefault(); startBtn.click(); }, {passive:false});

  revealBtn.addEventListener('click', ()=> {
    if(animating) return;
    const trueSlot = slots.find(s => Number(s.dataset.index) === hiddenIndex);
    if(trueSlot){ trueSlot.querySelector('.bowl')?.classList.add('show'); trueSlot.querySelector('.glass')?.classList.add('correct'); }
    modeText.textContent = 'Revealed';
    statusText.textContent = 'Answer revealed. Press Reset or Start to play again.';
  }, {passive:true});
  revealBtn.addEventListener('touchstart', (e)=> { e.preventDefault(); revealBtn.click(); }, {passive:false});

  resetBtn.addEventListener('click', resetGame, {passive:true});
  resetBtn.addEventListener('touchstart', (e)=> { e.preventDefault(); resetBtn.click(); }, {passive:false});

  function resetGame(){
    if(swapInterval){ clearInterval(swapInterval); swapInterval = null; }
    if(shuffleTimeout){ clearTimeout(shuffleTimeout); shuffleTimeout = null; }
    animating = false;
    modeText.textContent = 'Ready';
    statusText.textContent = 'Reset. Press Start to play.';
    clearConfetti();
    // re-build to recalc sizes & positions
    buildSlots();
  }

  // confetti
  function spawnConfettiAt(targetGlass){
    const rootRect = confettiRoot.getBoundingClientRect();
    const tRect = targetGlass.getBoundingClientRect();
    const centerX = (tRect.left + tRect.right)/2 - rootRect.left;
    const pieces = 20;
    const colors = ['#ff4d6d','#ffd166','#06d6a0','#4cc9f0','#ff7eb6','#c77dff'];
    for(let i=0;i<pieces;i++){
      const el = document.createElement('i');
      const w = 6 + Math.random()*10;
      const h = 10 + Math.random()*18;
      el.style.width = w + 'px';
      el.style.height = h + 'px';
      el.style.left = (centerX + (Math.random()*100 - 50)) + 'px';
      el.style.top = (tRect.top - rootRect.top) + 'px';
      el.style.background = colors[Math.floor(Math.random()*colors.length)];
      el.style.transform = `rotate(${Math.random()*360}deg)`;
      confettiRoot.appendChild(el);
      const destX = (Math.random()*300 - 150);
      const destY = rootRect.height + 80 + Math.random()*140;
      const rot = Math.random()*720 - 360;
      el.animate([
        { transform: `translateY(0px) rotate(${Math.random()*360}deg)`, opacity:1 },
        { transform: `translate(${destX}px, ${destY}px) rotate(${rot}deg)`, opacity:0.1 }
      ], { duration: 1200 + Math.random()*700, easing: 'cubic-bezier(.2,.8,.2,1)' });
      setTimeout(()=> { if(el && el.parentNode) el.parentNode.removeChild(el); }, 2200);
    }
  }
  function clearConfetti(){ confettiRoot.innerHTML = ''; }

  // recompute positions on resize (throttled)
  let resizeTimer = null;
  window.addEventListener('resize', ()=> {
    if(resizeTimer) clearTimeout(resizeTimer);
    resizeTimer = setTimeout(()=> {
      // recompute left positions and re-apply current order
      computeLeftPositions();
      applyLeftsInstant();
    }, 140);
  });

  // initial boot
  window.addEventListener('load', ()=> {
    buildSlots();
    // small entrance animation
    setTimeout(()=> {
      slots.forEach((s,i)=>{ s.style.transform = 'translateY(8px)'; setTimeout(()=> s.style.transform = '', 160 + i*80); });
    }, 120);
  });
})();
</script>
</body>
</html>
